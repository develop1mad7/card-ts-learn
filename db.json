{
  "dataLearn": [
    {
      "id": "810c",
      "title": "Статическая типизация",
      "desc": "Позволяет задавать типы для данных и проверять их на этапе разработки, до выполнения кода. Что дает возможность отловить ошибки в момент написания кода."
    },
    {
      "id": "7ca8",
      "title": "Явная типизация",
      "desc": "При создании переменной явно указывается тип данных :type"
    },
    {
      "id": "f5d5",
      "title": "Выводимая типизация",
      "desc": "Тип определяется и присваивается по первому заданному значению"
    },
    {
      "id": "0d77",
      "title": "Структурная типизация",
      "desc": "Если несколько типов имеет одинаковую структуру, то в месте ожидания одной структуры, можно подложить другую, без вреда для программы"
    },
    {
      "id": "4066",
      "title": "Специальные типы",
      "desc": "- any <br/> - unknow <br/> - never <br/> - void <br/> - литералы"
    },
    {
      "id": "87b1",
      "title": "Объединение(union) |",
      "desc": ": 'str' | number; \"value1\"| \"value2\" <br />\nМожет быть как различные по типу множества, так и перечисление допустимых значений, в случае объединения различных составных типов, допустимо использовать один из N-го кол-ва, все сразу или более одного."
    },
    {
      "id": "d4a6",
      "title": "Пересечение типов &",
      "desc": "Допускается использовать только все пересечения от type1 & type2"
    },
    {
      "id": "790a",
      "title": "Надтип и подтип",
      "desc": "Надтип - содержит в себе некоторые поля \"Подтипа\", что дает возможность использовать подтип при работе с надтипом(лишнее просто отсеется), а подтип не может использовать надтип в свою очередь для присвоения данных с типом надтип, т.к. в нем нет \"расширенных\" свойств."
    },
    {
      "id": "701f",
      "title": "Примитивные типы данных",
      "desc": ":number<br/>\n:string<br/>\n:boolean<br/>\n:null<br/>\n:undefined<br/>\n:symbol<br/>"
    },
    {
      "id": "49d6",
      "title": "Специальный тип ANY",
      "desc": "тип, который отключает типизацию, что в разработке не допустимо."
    },
    {
      "id": "4737",
      "title": "Специальный тип UNKNOW",
      "desc": "Тип, который позволяет безопасно отключать типизацию, для самостоятельной проверки типа и последующего его присвоения."
    },
    {
      "id": "93c5",
      "title": "Специальный тип NEVER",
      "desc": "Тип значение которого никогда не возвращается, содержит ошибку или указывает на бесконечный цикл, так же можно использовать для проверки switch позволяет определить, что значение попадает в default"
    },
    {
      "id": "556c",
      "title": "Специальный тип VOID",
      "desc": "Используется для функций, которые ничего не возвращают(undefined)."
    },
    {
      "id": "fdaa",
      "title": "Generic<T>",
      "desc": "создание универсального типа для какого либо поля. Т используется как аргумент в функциях, передается при объявлении generic. Когда мы заранее не знаем, какого типа могут быть данные, допустим data с сервера, вместо использования any, лучше создать generic"
    }
  ],
  "dataBook": [
    {
      "id": "e462",
      "title": "Компилятор",
      "desc": "Преобразует  человеку понятный код(программы) в абстрактное синтаксическое дерево(АСД). Далее АСД компилируется в низкоуровневую форму \"байт-код\", который можно запустить в среде выполнения и получить результат."
    },
    {
      "id": "d722",
      "title": "<b>АСД</b> - абстрактное синтаксическое дерево.",
      "desc": "Представляет собой структуру данных, игнорирующую пустые области, комментарии."
    },
    {
      "id": "6d01",
      "title": "Общие шаги выполнения программы",
      "desc": "Программа преобразуется в АСД -> АСД преобразуется в байт-код -> Байт-код исполняется средой выполнения и выводит результат."
    },
    {
      "id": "cd2f",
      "title": "Компилятор TS",
      "desc": "Код написанный на TypeScript преобразуется в АСД TS, после чему АДС TS проводит проверку типов и уже только потом TS преобразуется в JS. Проверка типов происходит на этапе компиляции, что позволяет отловить ошибки ещё на этапе разработки."
    },
    {
      "id": "718f",
      "title": "Система типов",
      "desc": "В TS используется две системы типов с явной и выводимой типизацией, первая рекомендуемая к использованию, поскольку в программе будет прописано явное использование типа, что в дальнейшем при масштабировании программы облегчит её чтение. Выводимая типизация - тип присваивается при определении переменной или задается дефолтное значение."
    },
    {
      "id": "f2c1",
      "title": "Тип :any",
      "desc": ":any не рекомендуется использовать в разработке, т.к. лишает элемента типизации, что в свою очередь предоставляет возможность делать с элементом всё, что угодно и даже вызывать не существующие методы, конечно на этапе запуска программы это будет выявлено. Но сама магия TS в таком случае бездействует, т.к. программист(я) сам и допустим использование этого типа."
    },
    {
      "id": "4cd3",
      "title": "Тип :unknow",
      "desc": ":unknow используется в случая, когда заведомо неизвестен тип приходящих данных, а для использования в дальнейшем, необходимо уточнить, какой это именно тип данных. Это отличная альтернатива :any, т.к. без уточнения типа, невозможно работать с данными, поэтому это более безопасная типизация."
    },
    {
      "id": "9183",
      "title": "Тип :boolean",
      "desc": ":boolean логический тип, который можно отнести к литеральному типу, т.к. имеет только два возможных значения true/false, типизировать можно как общим типом :boolean так и узким :true/:false, последние имеют тип :boolean с одним возможным значением."
    },
    {
      "id": "b50b",
      "title": "Тип :number",
      "desc": ":number используется для работы с числами -+ или бесконечными, с плавающей точкой. Допустимы операции, которые выводят булевой тип. Применимы все доступные методы для работы с числами."
    },
    {
      "id": "59db",
      "title": "Тип :bigint",
      "desc": ":bigint аналогичен по применению с :number, но имеет гораздо более широкий диапазон чисел"
    },
    {
      "id": "a473",
      "title": "Тип :string",
      "desc": ":string набор используемый для работы со строками, доступны такие операции как конкатенация, срез(.slice) и т.д."
    },
    {
      "id": "f4ab",
      "title": "Структурная типизация",
      "desc": "В JS как и в TS объекты проверяются по структуре, если они схожи по свойствам и имеют схожие методы в пересечении, в таком случае они взаимозаменяемы. Это предполагает, что js не проверяет имя объекта, ему важно лишь наличие или отсутствие(при вызове не существующего) метода/свойства."
    },
    {
      "id": "a962",
      "title": "Тип :object",
      "desc": ":object предпочтительный способ описание создание типа объекта, это описание самой структуры объекта, какие поля обязательны, какие опциональные, а какие могу появляться после [key: number || string]: type."
    },
    {
      "id": "dbf2",
      "title": "Типобезопасность",
      "desc": "Это когда среда/язык следит за правильным использованием данных и не дает возможность применять не соответствующие типу операции/методы и т.д."
    },
    {
      "id": "2cb8",
      "title": "Псевдоним Type",
      "desc": "type используется для описания повторно используемого типа при объявлении разных переменных, что облегчает чтение и написание программы, т.к. имена типов часто описательные. Плюс как и в случае с объявлением переменных, в пределах одного блока нельзя создать два одинаковых типа, что исключается \"перетирку\" одного другим."
    },
    {
      "id": "22ed",
      "title": "Объединение -  \" | \"",
      "desc": "Позволят объединить два типа в один, подразумевая использование одного из них для работы с типами данных"
    },
    {
      "id": "eced",
      "title": "Пересечение - \" & \"",
      "desc": "Пересечение это слияние двух типов, подразумевающее наличие свойств и того и другого типа."
    },
    {
      "id": "8831",
      "title": "Тип :array",
      "desc": ":array тип однородных(предпочтительно) данных, который допускает использование методов массива, без явной типизации типа элемента массива, ts постарается вывести тип на основе первого присвоения, если же был присвоен пустой массив, то будет присвоеy any[], что в свою очередь не ограничивает наполнение массива разнородной информацией, однако в таком случае при работе с массивом потребуется проверка на каждой итерации о соответствии итерируемого элементу конкретному узкому типу, например :number или :string. Если же был выведен any[] где то в функции и ему были присвоены разного рода типы, при возращении этого массива, будет присвоен тип на основе типов элементов."
    },
    {
      "id": "fdee",
      "title": "Тип :tuple",
      "desc": ":tuple(Кортежи) это подтип :array и используется для создания массивов ограниченной длины и типами данных в строгой последовательности. Можно создать массив кортежей."
    },
    {
      "id": "453d",
      "title": "Тип :readonly [] || [type, type]",
      "desc": ":readonly ограничивает работу с массивами и кортежами для их изменения, делает данные неизменяемыми, для работы с массивом потребуется использовать неизменяемые методы, .concat() например, для добавления элемента в массив."
    },
    {
      "id": "4e97",
      "title": "Типы :null, :undefined",
      "desc": "Оба типа взаимозаменяемые, однако есть различие в трактовке данных, undefined обозначает, что значение в целом не определено, тогда как null говорит о том, что значение пустое, ничего не значащее. По возможности возвращаемое значение лучше использовать как null, если такая необходимость имеется в целом."
    },
    {
      "id": "cd68",
      "title": "Типы :void, :never для функций",
      "desc": "В контексте возвращаемого значения функции имеет следующие значения, :void означает что функция явно ничего не возвращает, то-есть не имеет return, а например побочный эффект(side-effect), классический console.log(name), :never означает, что функция никогда ничего не возвращаем(выбрасывает исключение или выполняется бесконечно)."
    },
    {
      "id": "bcf9",
      "title": "Enum",
      "desc": "подходит для группировки имен по общему смыслу, имеется ряд уязвимостей при использовании без const enum и если не задать значение для перечисления. Хорошая альтернатива использовать union \" | \"  для выбора одного из доступных значений, правда потребуется дополнительная проверка условиями."
    },
    {
      "id": "9749",
      "title": "Axios",
      "desc": "Библиотека для работы с асинхронными запросами"
    }
  ]
}